/* ncount.cpp by Jason Lai based on code by Natasa Przulj  */
/* Modified to put variables on heap rather than stack  (to be able to process huge networks) by Oleksii */
/* Modified to use bit vectors (8-times less memory) in adjacency matrix by Wayne Hayes, 16 May 2009 */
/* Modified to use maps (sparse) for adjacency matrix by Wayne Hayes, 16 May 2009 */
/* suggested g++-3.4 compile flags: -O3 -funroll-loops     */
/* Usage: ncount <input graph> <output prefix>
 * Counts graphlets and graphlet degrees (called node classes here)
 *
 * Basic algorithm: Brute force enumeration of 3-5 node connected subgraphs
 *   With some overlap that needs to be factored out later.
 *
 * Process is:
 *   Pick node A, pick a node B adj to A, pick a node C adj to B, pick a 
 *   node D adj to C, pick a node E adj to D. And each node can only 
 *   appear once in the subgraph.
 *
 *   Use a separate process for graphlets containing the claw, by picking 
 *   a center node and then picking the rest.
 *
 *   Examine the edges between them to determine which graphlet the 
 *   subgraph corresponds to. Classify each node in the graphlet and add 
 *   it to the count for that graphlet type.
 *
 *   At the end, divide out the overcount and print out how many 
 *   graphlets touch at the same node class/type.
 */

// set this to 1 if normal ncount runs out of memory, but be warned
// it makes ncount run 10-20 times slower.
#define HUGE_GRAPHS 0

#include <iostream>
#include <time.h> //Oleksii
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <map>        /* STL ordered dictionary class */

#define PROGRESS_INFO 1 /* Print status to stdout */
#define PATH_MAX 256 //Oleksii
/* These lookup tables were generated by analyzing sample graphs representing
 * each graphlet, and then adjusting the table sizes for perfect hashing.
 */

/* Lookup table for graphlets. Calculated by:
 * [(sum of (degree % 4 for node/neighbors))/2][edge count/2]-4
 * Special handling needed for X23 and X25
 */
const char gtable [][8] = 
{{-1,-1,10,-1,-1,8},{-1,11,-1,-1,15,14,12},{17,19,-1,16,18,20},
{-1,-1,23,24,-1,21},{-1,-1,26,25},{-1,-1,-1,-1,-1,-1,27},{28}};

/* times counted per graphlet type */
const int overcount[] = {2, 6, 2, 6, 8, 4, 12, 24, 2, 2, 24, 2, 4, 4, 10, 4,
                         4, 8, 8, 12, 14, 12, 12, 20, 28, 36, 48, 72, 120};

const int ordered_overcount[] = {1,1,1,
                                 1,
                                 1,1,1,1,1,1,1,1,1,1,1,1,
                                 1,1,1,1,
                                 1,1,1,
                                 1,1,1,1,1,1,1,1,1,1,1,1,
                                 1,1,1,1,1,1,
                                 1};

typedef long long int64; // sadly, long long is not standard in C++ ... yet

struct temp_data /* linked list of edges */
{
    struct temp_data *next;
    int dst;
};

void swap(char *x,char *y) {
    char temp;
    temp=*x;
    *x=*y;
    *y=temp;
}

void get_permutations(char *s,int i,int n) {
    if(i==n) {
        printf("%s\n",s);
    }
    else {
        for(int j=i;j<=n;j++) {
            swap(s+i,s+j);
            get_permutations(s,i+1,n);
            swap(s+i,s+j);
        }
    }
}

/* Handy macros; for details see the definition of edges_for */
#define DEGREE(x) (edges_for[x + 1] - edges_for[x])
#define foreach_adj(x,y) for(x = edges_for[y]; x != edges_for[y+1]; x++)

void die(const char *msg)
{
    fprintf(stderr, "ERROR: %s\n", msg);
    exit(1);
}

int node_compare(char *a,char *b) {
    int va=atoi(a);
    int vb=atoi(b);
    if(va<vb) return -1;
    if(va>vb) return  1;
    return strcmp(a,b);
}

void get_order(char *a,char *b,char *c,char *o)
{
    int oa=0,ob=0,oc=1;
    int compAB = node_compare(a,b);
    int compCA = node_compare(c,a);
    int compCB = node_compare(c,b);
    if(compAB<0) { oa=1;ob=2; } else if(compAB>0) { oa=2;ob=1; };
    if(compCA<0) { oa++; }
    if(compCB<0) { ob++; }
    if(compCA>0) { oc++; }
    if(compCB>0) { oc++; }
    if(oa+ob+oc != 6)
        sprintf(o,"NULL");
    else
        sprintf(o,"%d%d%d",oa,ob,oc);
}

void get_order(char *a,char *b,char *c,char *d,char *o)
{
    int oa=0,ob=0,oc=1,od=1;
    int compAB=node_compare(a,b);
    int compCA=node_compare(c,a);
    int compCB=node_compare(c,b);
    int compDA=node_compare(d,a);
    int compDB=node_compare(d,b);
    int compDC=node_compare(d,c);
    if(compAB<0) { oa=1;ob=2; } else if(compAB>0) { oa=2;ob=1; };
    if(compCA<0) { oa++; }
    if(compCB<0) { ob++; }
    if(compCA>0) { oc++; }
    if(compCB>0) { oc++; }
    if(compDA<0) { oa++; }
    if(compDB<0) { ob++; }
    if(compDC<0) { oc++; }
    if(compDA>0) { od++; }
    if(compDB>0) { od++; }
    if(compDC>0) { od++; }
    if(oa+ob+oc+od != 10)
        sprintf(o,"NULL");
    else
        sprintf(o,"%d%d%d%d",oa,ob,oc,od);
}

void get_order(char *a,char *b,char *c,char *d,char *e,char *o)
{
    int oa=0,ob=0,oc=1,od=1,oe=1;
    int compAB = node_compare(a,b);
    int compCA = node_compare(c,a);
    int compCB = node_compare(c,b);
    int compDA = node_compare(d,a);
    int compDB = node_compare(d,b);
    int compDC = node_compare(d,c);
    int compEA = node_compare(e,a);
    int compEB = node_compare(e,b);
    int compEC = node_compare(e,c);
    int compED = node_compare(e,d);

    if(compAB<0) { oa=1;ob=2; } else if(compAB>0) { oa=2;ob=1; };
    if(compCA<0) { oa++; }
    if(compCB<0) { ob++; }
    if(compCA>0) { oc++; }
    if(compCB>0) { oc++; }
    if(compDA<0) { oa++; }
    if(compDB<0) { ob++; }
    if(compDC<0) { oc++; }
    if(compDA>0) { od++; }
    if(compDB>0) { od++; }
    if(compDC>0) { od++; }
    if(compEA<0) { oa++; }
    if(compEB<0) { ob++; }
    if(compEC<0) { oc++; }
    if(compED<0) { od++; }
    if(compEA>0) { oe++; }
    if(compEB>0) { oe++; }
    if(compEC>0) { oe++; }
    if(compED>0) { oe++; }
    if(oa+ob+oc+od+oe != 15)
        sprintf(o,"NULL");
    else
        sprintf(o,"%d%d%d%d%d",oa,ob,oc,od,oe);
}

void count(FILE *f, FILE *out, char *outname)
{
    int V, E, E_undir, i, j;
    time_t start_time = time(0);

    fscanf(f, "LEDA.GRAPH\n");
    fscanf(f, "%*s\n");
    fscanf(f, "%*s\n");

    do { if( fscanf(f, "%d\n", &V) < 0 ) V = -1; }
    while(V < 0);

    char **node_names = new char*[V];

    char buf[101];
    for(i = 0; i < V; i++)
    {
        if(fscanf(f, "|{ %100[^}] }|\n", buf) < 1) die("Invalid input file");
        node_names[i] = strdup(buf);
        assert(node_names[i] != NULL);
    }

    fscanf(f, "%d", &E_undir);
    E = E_undir * 2;

    assert(E_undir >= 0);

    struct temp_data **heads = new temp_data*[V]; //Oleksii
    struct temp_data *links = new temp_data[E]; //Oleksii
    for(i = 0; i < V; i++)
        heads[i] = NULL;

    struct temp_data *link;

#if HUGE_GRAPHS
    /* Use a map (sparse associated array) for the adjacency matrix */
    /* Use int64 as the index, with high 32 bits encoding row, low 32 bits encoding column */
    #define Connect(i,j) (adjmat[((int64)(i))<<32 | j] = 1)
    #define Connected(i,j) (adjmat[((int64)(i))<<32 | j])
    std::map<const int64, char> adjmat;
    for(i = 0; i < V; i++)
        Connect(i,i); /* optimization hack */
#else
    /* allocate some space for the adjacency matrix */
    char **adjmat = new char*[V]; //Oleksii
    /* Use a bit vector to store each row of the adjancency matrix, so
     * that each edge takes up only one bit.
     */
    #define Connect(i,j) (adjmat[i][(j)/8] |= 1<<((j)%8))
    #define Connected(i,j) (adjmat[i][(j)/8] & (1<<((j)%8)))
    for(i = 0; i < V; i++)
    {
        /* calloc zeroes the memory for us */
        adjmat[i] = (char *) calloc(V/8+1, sizeof(char));
        if(!adjmat[i]) { perror("calloc"); exit(1); }

        Connect(i,i); /* optimization hack */
    }
#endif
    /* First stores edges in linked lists by node (vertex) so we know how many
     * edges there are for each node, then copy to an array for efficiency.
     */

    /* add data to linked list for intermediate storage */
    for(i = 0; i < E_undir; i++)
    {
        int src = -1, dst = -1;
        fscanf(f, "%d %d %*d %*s", &src, &dst);
        src -= 1; /* LEDA graph files are 1-indexed */
        dst -= 1;

        if(src < 0 || dst < 0)
        {
            fprintf(stderr,"Error: node numbers must be greater than zero.\n");
            exit(1);
        }

        if(src == dst) continue; /* ignore self-loops */

        /* See if edge is already in list */
        int bad = 0;
        for(link = heads[src]; link; link = link->next)
        {
            if(link->dst == dst)
            {
                bad = 1; /* don't allow parallel edges */
                break;
            }
        }
        if(bad) continue;

        struct temp_data *ntemp1 = &links[i*2];
        struct temp_data *ntemp2 = &links[i*2+1];

        /* Add to front of node's linked list */
        ntemp1->next = heads[src]; ntemp1->dst = dst;
        ntemp2->next = heads[dst]; ntemp2->dst = src;
        heads[src] = ntemp1;
        heads[dst] = ntemp2;

        Connect(src, dst);
        Connect(dst, src);
    }

    /* The edges[] array stores edges by node sequentially, so the last edge
       of node n is followed by the first edge of n+1. edges_for[] stores 
       a pointer to the first edge of a node. */

    int **edges_for = new int*[V+1]; //Oleksii
    int *edges = new int[E*2+1]; //Oleksii

    int *edge_last = &edges[0];

    for(i = 0; i < V; i++)
    {
        edges_for[i] = edge_last;
        for(link = heads[i]; link; link = link->next)
        {
            *edge_last = link->dst;
            edge_last++;
        }
    }
    edges_for[i] = edge_last;

    int64 gcount[29] = {};
    int64 ordered_gcount[102] = {};

    /* start counting */

    int *pb, *pc, *pd, *pe;
    int a, b, c, d, e, x;
    char order[10];

    for(a = 0; a < V; a++)
    {
//#if PROGRESS_INFO
//      fprintf(stderr, "\rnode # %5d (%.1f%%) [%d min elapsed]", a, 
//              100.0 * (float) a / V, (time(0) - start_time) / 60);
//#endif

      foreach_adj(pb, a)
      {
        b = *pb;
        if(b == a) continue;

        foreach_adj(pc, b)
        {
          c = *pc;
          if(c == a || c == b) continue;

            get_order(node_names[a],node_names[b],node_names[c],order);
            //printf("%s %s %s = %s\n",node_names[a],node_names[b],node_names[c],order);
            if(strcmp(order,"NULL")==0) {
                printf("Error: Invalid node order. Check the network.\n");
                printf("Instance: <%s, %s, %s>\n",
                    node_names[a],node_names[b],node_names[c]);
                exit(1);
            }
          /* count adjacent edges */
          int deg3_a = 0, deg3_b = 0, deg3_c = 0;

	  // The "!!" is a double negation, which maps any non-zero integer to 1
          x = !!Connected(a,b); deg3_a += x; deg3_b += x;
          x = !!Connected(a,c); deg3_a += x; deg3_c += x;
          x = !!Connected(b,c); deg3_b += x; deg3_c += x;

          if(deg3_a == 1)
          {
            gcount[0]++; /* path */
            //printf("%d -> %d -> %d\n",deg3_a,deg3_b,deg3_c);
            if(strcmp(order,"123")==0) ordered_gcount[0]++;
            if(strcmp(order,"132")==0) ordered_gcount[1]++;
            if(strcmp(order,"213")==0) ordered_gcount[2]++;

            // look for claws
            if(DEGREE(b) > 2)
            foreach_adj(pd, b)
            {
                d = *pd;
                if(Connected(a,d) + Connected(c,d) == 0)
                {
                    get_order(node_names[a],node_names[b],
                              node_names[c],node_names[d],
                              order);
                    //printf("%s %s %s %s = %s\n",node_names[a],node_names[b],node_names[c],node_names[d],order);
                    if(strcmp(order,"NULL")==0) {
                        printf("Error: Invalid node order. Check the network.\n");
                        printf("Instance: <%s, %s, %s, %s>\n",
                            node_names[a],node_names[b],node_names[c],node_names[d]);
                        exit(1);
                    }
                    // look for X11
                    if(DEGREE(b) > 3)
                    foreach_adj(pe, b)
                    {
                        e = *pe;
                        if(Connected(a,e) + Connected(c,e) + Connected(d,e) == 0)
                        {
                            gcount[10]++; /* X11 */
                        }
                    }

                    gcount[3]++; /* Claw! */
                    if(strcmp(order,"2134")==0) ordered_gcount[16]++;
                    if(strcmp(order,"1234")==0) ordered_gcount[17]++;
                    if(strcmp(order,"1324")==0) ordered_gcount[18]++;
                    if(strcmp(order,"1423")==0) ordered_gcount[19]++;
                }
            }
          }
          else
          {
            gcount[1]++; /* triangle */
            if(strcmp(order,"123")==0)
                ordered_gcount[3]++;
          }

          foreach_adj(pd, c)
          {
            d = *pd;
            if(d == a || d == b || d == c) continue;
            get_order(node_names[a],node_names[b],
                      node_names[c],node_names[d],
                      order);
            //printf("%s %s %s %s = %s\n",node_names[a],node_names[b],node_names[c],node_names[d],order);
            if(strcmp(order,"NULL")==0) {
                printf("Error: Invalid node order. Check the network.\n");
                printf("Instance: <%s, %s, %s, %s>\n",
                    node_names[a],node_names[b],node_names[c],node_names[d]);
                exit(1);
            }

            /* classify most 4-node graphlets (excluding some claws) */

            int deg4_a = deg3_a, deg4_b = deg3_b, deg4_c = deg3_c, deg4_d = 0;

            x = !!Connected(a,d); deg4_d += x; deg4_a += x;
            x = !!Connected(b,d); deg4_d += x; deg4_b += x;
            x = !!Connected(c,d); deg4_d += x; deg4_c += x;

            int num_edges = deg4_a + deg4_b + deg4_c + deg4_d;

            if(num_edges == 6)
            {
              gcount[2]++; /* P4 */
              if(strcmp(order,"1234")==0)
                  ordered_gcount[4]++;
              if(strcmp(order,"1243")==0)
                  ordered_gcount[5]++;
              if(strcmp(order,"1324")==0)
                  ordered_gcount[6]++;
              if(strcmp(order,"1342")==0)
                  ordered_gcount[7]++;
              if(strcmp(order,"1423")==0)
                  ordered_gcount[8]++;
              if(strcmp(order,"1432")==0)
                  ordered_gcount[9]++;
              if(strcmp(order,"2134")==0)
                  ordered_gcount[10]++;
              if(strcmp(order,"2143")==0)
                  ordered_gcount[11]++;
              if(strcmp(order,"2314")==0)
                  ordered_gcount[12]++;
              if(strcmp(order,"3124")==0)
                  ordered_gcount[13]++;
              if(strcmp(order,"3142")==0)
                  ordered_gcount[14]++;
              if(strcmp(order,"3214")==0)
                  ordered_gcount[15]++;

              foreach_adj(pe, b) /* look for X10 */
              {
                  e = *pe;
                  if(Connected(a,e) + Connected(c,e) + Connected(d,e) == 0)
                  {
                      gcount[9]++; /* X10 */
                  }
              }
            }
            else if(num_edges == 10)
            {
              gcount[6]++; /* Diamond */
              if(Connected(a,c) && !Connected(b,d))
              {
                  if(strcmp(order,"1324")==0)
                      ordered_gcount[35]++;
                  if(strcmp(order,"1234")==0)
                      ordered_gcount[36]++;
                  if(strcmp(order,"1243")==0)
                      ordered_gcount[37]++;
                  if(strcmp(order,"2134")==0)
                      ordered_gcount[38]++;
                  if(strcmp(order,"2143")==0)
                      ordered_gcount[39]++;
                  if(strcmp(order,"3142")==0)
                      ordered_gcount[40]++;
              }
            }
            else if(num_edges == 12)
            {
              gcount[7]++; /* K4 */
              if(strcmp(order,"1234")==0)
                ordered_gcount[41]++;
            }
            else if(num_edges == 8) /* C4 or Flower */
            {
              if(deg4_b == 3 || deg4_c == 3)
              {
                gcount[5]++; /* Flower */
                if(deg4_b == 3)
                {
                    if(strcmp(order,"1234")==0)
                        ordered_gcount[23]++;
                    if(strcmp(order,"1324")==0)
                        ordered_gcount[24]++;
                    if(strcmp(order,"1423")==0)
                        ordered_gcount[25]++;
                    if(strcmp(order,"2134")==0)
                        ordered_gcount[26]++;
                    if(strcmp(order,"2314")==0)
                        ordered_gcount[27]++;
                    if(strcmp(order,"2413")==0)
                        ordered_gcount[28]++;
                    if(strcmp(order,"3124")==0)
                        ordered_gcount[29]++;
                    if(strcmp(order,"3214")==0)
                        ordered_gcount[30]++;
                    if(strcmp(order,"3412")==0)
                        ordered_gcount[31]++;
                    if(strcmp(order,"4123")==0)
                        ordered_gcount[32]++;
                    if(strcmp(order,"4213")==0)
                        ordered_gcount[33]++;
                    if(strcmp(order,"4312")==0)
                        ordered_gcount[34]++;

                    // only do this for half the cases, to reduce overcount
                    foreach_adj(pe, b)
                    {
                        e = *pe;
                        if(Connected(a,e) + Connected(c,e) + Connected(d,e) == 0)
                        {
                            gcount[13]++; /* X14 */
                        }
                    }
                }
              }
              else
              {
                gcount[4]++; /* C4 */
                if(strcmp(order,"1234")==0)
                    ordered_gcount[20]++;
                if(strcmp(order,"1324")==0)
                    ordered_gcount[21]++;
                if(strcmp(order,"1243")==0)
                    ordered_gcount[22]++;
              }
            }

            /* classify most 5-node graphlets */
            foreach_adj(pe, d)
            {
              e = *pe;
              if(e == a || e == b || e == c || e == d) continue;

              get_order(node_names[a],node_names[b],
                        node_names[c],node_names[d],
                        node_names[e],order);
              //printf("%s %s %s %s %s = %s\n",node_names[a],node_names[b],node_names[c],node_names[d],node_names[e],order);

              int deg5_a = deg4_a, deg5_b = deg4_b, deg5_c = deg4_c,
                  deg5_d = deg4_d, deg5_e = 0;

              x = !!Connected(e,a); deg5_e += x; deg5_a += x;
              x = !!Connected(e,b); deg5_e += x; deg5_b += x;
              x = !!Connected(e,c); deg5_e += x; deg5_c += x;
              x = !!Connected(e,d); deg5_e += x; deg5_d += x;

              /* add degrees of node and neighbors to find each ndeg */
              int ndeg_a = deg5_a, ndeg_b = deg5_b, ndeg_c = deg5_c,
                  ndeg_d = deg5_d, ndeg_e = deg5_e;
              if(Connected(a,b)) { ndeg_a += deg5_b; ndeg_b += deg5_a; }
              if(Connected(a,c)) { ndeg_a += deg5_c; ndeg_c += deg5_a; }
              if(Connected(a,d)) { ndeg_a += deg5_d; ndeg_d += deg5_a; }
              if(Connected(a,e)) { ndeg_a += deg5_e; ndeg_e += deg5_a; }
              if(Connected(b,c)) { ndeg_b += deg5_c; ndeg_c += deg5_b; }
              if(Connected(b,d)) { ndeg_b += deg5_d; ndeg_d += deg5_b; }
              if(Connected(b,e)) { ndeg_b += deg5_e; ndeg_e += deg5_b; }
              if(Connected(c,d)) { ndeg_c += deg5_d; ndeg_d += deg5_c; }
              if(Connected(c,e)) { ndeg_c += deg5_e; ndeg_e += deg5_c; }
              if(Connected(d,e)) { ndeg_d += deg5_e; ndeg_e += deg5_d; }

              // note that (x%4 + y%4) is not the same as (x+y)%4
              int hash = (ndeg_a % 4 + ndeg_b % 4 + ndeg_c % 4 + ndeg_d % 4
                        + ndeg_e % 4);
              int deg_total = deg5_a + deg5_b + deg5_c + deg5_d + deg5_e;
              int gtype = gtable[deg_total/2 - 4][hash/2];

              /* not caught by table */
              if(deg_total == 14 && hash == 6)
                gtype = (ndeg_a > 12 || ndeg_a == 5) ? 22 : 24;

              assert(gtype > 7 && gtype < 29);
              
              switch(gtype) {
                  case 8:
                    if(strcmp(order,"12345")==0)
                        ordered_gcount[41+1]++;
                    if(strcmp(order,"12354")==0)
                        ordered_gcount[41+2]++;
                    if(strcmp(order,"12435")==0)
                        ordered_gcount[41+3]++;
                    if(strcmp(order,"12453")==0)
                        ordered_gcount[41+4]++;
                    if(strcmp(order,"12534")==0)
                        ordered_gcount[41+5]++;
                    if(strcmp(order,"12543")==0)
                        ordered_gcount[41+6]++;
                    if(strcmp(order,"13245")==0)
                        ordered_gcount[41+7]++;
                    if(strcmp(order,"13254")==0)
                        ordered_gcount[41+8]++;
                    if(strcmp(order,"13425")==0)
                        ordered_gcount[41+9]++;
                    if(strcmp(order,"13452")==0)
                        ordered_gcount[41+10]++;
                    if(strcmp(order,"13524")==0)
                        ordered_gcount[41+11]++;
                    if(strcmp(order,"13542")==0)
                        ordered_gcount[41+12]++;
                    if(strcmp(order,"14235")==0)
                        ordered_gcount[41+13]++;
                    if(strcmp(order,"14253")==0)
                        ordered_gcount[41+14]++;
                    if(strcmp(order,"14325")==0)
                        ordered_gcount[41+15]++;
                    if(strcmp(order,"14352")==0)
                        ordered_gcount[41+16]++;
                    if(strcmp(order,"14523")==0)
                        ordered_gcount[41+17]++;
                    if(strcmp(order,"14532")==0)
                        ordered_gcount[41+18]++;
                    if(strcmp(order,"15234")==0)
                        ordered_gcount[41+19]++;
                    if(strcmp(order,"15243")==0)
                        ordered_gcount[41+20]++;
                    if(strcmp(order,"15324")==0)
                        ordered_gcount[41+21]++;
                    if(strcmp(order,"15342")==0)
                        ordered_gcount[41+22]++;
                    if(strcmp(order,"15423")==0)
                        ordered_gcount[41+23]++;
                    if(strcmp(order,"15432")==0)
                        ordered_gcount[41+24]++;
                    if(strcmp(order,"21345")==0)
                        ordered_gcount[41+25]++;
                    if(strcmp(order,"21354")==0)
                        ordered_gcount[41+26]++;
                    if(strcmp(order,"21435")==0)
                        ordered_gcount[41+27]++;
                    if(strcmp(order,"21453")==0)
                        ordered_gcount[41+28]++;
                    if(strcmp(order,"21534")==0)
                        ordered_gcount[41+29]++;
                    if(strcmp(order,"21543")==0)
                        ordered_gcount[41+30]++;
                    if(strcmp(order,"23145")==0)
                        ordered_gcount[41+31]++;
                    if(strcmp(order,"23154")==0)
                        ordered_gcount[41+32]++;
                    if(strcmp(order,"23415")==0)
                        ordered_gcount[41+33]++;
                    if(strcmp(order,"23514")==0)
                        ordered_gcount[41+34]++;
                    if(strcmp(order,"24135")==0)
                        ordered_gcount[41+35]++;
                    if(strcmp(order,"24153")==0)
                        ordered_gcount[41+36]++;
                    if(strcmp(order,"24315")==0)
                        ordered_gcount[41+37]++;
                    if(strcmp(order,"24513")==0)
                        ordered_gcount[41+38]++;
                    if(strcmp(order,"25134")==0)
                        ordered_gcount[41+39]++;
                    if(strcmp(order,"25143")==0)
                        ordered_gcount[41+40]++;
                    if(strcmp(order,"25314")==0)
                        ordered_gcount[41+41]++;
                    if(strcmp(order,"25413")==0)
                        ordered_gcount[41+42]++;
                    if(strcmp(order,"31245")==0)
                        ordered_gcount[41+43]++;
                    if(strcmp(order,"31254")==0)
                        ordered_gcount[41+44]++;
                    if(strcmp(order,"31425")==0)
                        ordered_gcount[41+45]++;
                    if(strcmp(order,"31524")==0)
                        ordered_gcount[41+46]++;
                    if(strcmp(order,"32145")==0)
                        ordered_gcount[41+47]++;
                    if(strcmp(order,"32154")==0)
                        ordered_gcount[41+48]++;
                    if(strcmp(order,"32415")==0)
                        ordered_gcount[41+49]++;
                    if(strcmp(order,"32514")==0)
                        ordered_gcount[41+50]++;
                    if(strcmp(order,"34125")==0)
                        ordered_gcount[41+51]++;
                    if(strcmp(order,"34215")==0)
                        ordered_gcount[41+52]++;
                    if(strcmp(order,"35124")==0)
                        ordered_gcount[41+53]++;
                    if(strcmp(order,"35214")==0)
                        ordered_gcount[41+54]++;
                    if(strcmp(order,"41235")==0)
                        ordered_gcount[41+55]++;
                    if(strcmp(order,"41325")==0)
                        ordered_gcount[41+56]++;
                    if(strcmp(order,"42135")==0)
                        ordered_gcount[41+57]++;
                    if(strcmp(order,"42315")==0)
                        ordered_gcount[41+58]++;
                    if(strcmp(order,"43125")==0)
                        ordered_gcount[41+59]++;
                    if(strcmp(order,"43215")==0)
                        ordered_gcount[41+60]++;
                    //exit(1);
                    break;
                  case 9:
                    printf("Error: Invalid gtype <%d> detected\n",gtype);
                    exit(1);
                    break;
                  case 10:
                    printf("Error: Invalid gtype <%d> detected\n",gtype);
                    exit(1);
                    break;
                  case 11:
                    break;
                  case 12:
                    break;
                  case 13:
                    printf("Error: Invalid gtype <%d> detected\n",gtype);
                    exit(1);
                    break;
                  case 14:
                    break;
                  case 15:
                    break;
                  case 16:
                    break;
                  case 17:
                    break;
                  case 18:
                    break;
                  case 19:
                    break;
                  case 20:
                    break;
                  case 21:
                    break;
                  case 22:
                    break;
                  case 23:
                    break;
                  case 24:
                    break;
                  case 25:
                    break;
                  case 26:
                    break;
                  case 27:
                    break;
                  case 28:
                    break;
              }
              
              gcount[gtype]++;
              //printf("%d\n",gtype);
            }
          }
        }
      }
    }

//#if PROGRESS_INFO
//    fprintf(stderr, "\nCounting complete.\n");
//#endif

    /* output */
    char temp[PATH_MAX];
    FILE *gr_out = NULL;

    int errors = 0;

    /* print graphlet counts */
/*    for(i = 0; i < 29; i++)
    {
	    assert(gcount[i] % overcount[i] == 0);
        gcount[i]=gcount[i]/overcount[i];
        fprintf(out, "%d\t%lld\n", i+1, gcount[i]);
        if(gr_out)
            fprintf(gr_out, "%d\t%lld\n", i+1, gcount[i]);
    }
*/
//    for(i = 0; i < 102; i++)
    for(i = 0; i < 42; i++)
    {
	    //assert(ordered_gcount[i] % ordered_overcount[i] == 0);
        //ordered_gcount[i]=ordered_gcount[i]/ordered_overcount[i];
        fprintf(out, "%d\t%lld\n", i+1, ordered_gcount[i]);
        if(gr_out)
            fprintf(gr_out, "%d\t%lld\n", i+1, ordered_gcount[i]);
    }
//    printf("%d %d %d %d %d\n",gcount[3],ordered_gcount[16],
//    ordered_gcount[17],ordered_gcount[18],ordered_gcount[19]);
/*    std::cout << gcount[0]/overcount[0] << "\t"
              << ordered_gcount[0]/ordered_overcount[0] << "\t"
              << ordered_gcount[1]/ordered_overcount[1] << "\t"
              << ordered_gcount[2]/ordered_overcount[2] << "\n";
*/

    if(errors) exit(1);
}

int main(int argc, char *argv[])
{
    if(argc != 3)
    {
        fprintf(stderr, "Usage: %s <input graph> <output name>\n", argv[0]);
        return 1;
    }

    FILE *fp = fopen(argv[1], "r");
    if(!fp) { perror(argv[1]); return 1; }

    FILE *out;

    if(!strcmp(argv[2], "-"))
        out = stdout;
    else
    {
        /* naive check to avoid overwriting files by accident */
//        out = fopen(argv[2], "r");
//        if(out) { fprintf(stderr, "File %s exists.\n", argv[2]); return 1; }

        out = fopen(argv[2], "w");
        if(!out){ perror(argv[2]); return 1; }
    }

    count(fp, out, argv[2]);

    fclose(fp);
    if(out != stdout) fclose(out);

    return 0;
}
